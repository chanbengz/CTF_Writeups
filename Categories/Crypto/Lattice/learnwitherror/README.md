# Learn With Error

> **Description**
> `你说你要AK？哈？`
>
> **Attachmets**
> **[learnwitherror.py](./learnwitherror.py) [output.txt](./output.txt)**

## Challenge overview

**`learnwitherror.py:`**

```python
import numpy as np
import secrets

def rand(seed):
    seeds = [(seed >> (3 * i)) & 7 for i in range(nseeds)]
    a = 5
    b = 7
    while True:
        for i in range(nseeds):
            seeds[i] = (a * seeds[i] + b) & 7
            yield seeds[i]

q = 2**142 + 217
n = 69
nseeds = 142
rng = rand(secrets.randbits(3 * nseeds))
with open("flag.txt", "rb") as f:
    flag = f.read().strip()
bits = f'{int.from_bytes(flag, "big"):0{len(flag) * 8}b}'
s = np.array([secrets.randbits(1) for _ in range(n)])

for bit in map(int, bits):
    A = np.array([secrets.randbelow(q) for _ in range(n * n)]).reshape((n, n))
    b = [A @ s + np.array([next(rng) for _ in range(n)]), np.array([secrets.randbelow(q) for _ in range(n)])][bit]
    print(list(map(hex, A.reshape(-1))), list(map(hex, b % q)))
```

The script generates a secret $69$-dimension vector $s$ with elements $0$ or $1$. They encrypt the flag by looping for each bit of the flag:
* Firstly, generate a random $69 \times 69$ matrix $A$, with elements $< q$.
* If the flag bit is $0 \Rightarrow$ return $b = A \times s + e \text{ (mod q)}$, where $e$ is an error vector with elements $<7$
* If the flag bit is $1 \Rightarrow$ return a random vector $b$ with elements $< q$

## Solution

Firstly we known that the flag start with $\text{ictf}$, so the first bit must be $0$, so we extract the first line of `output.txt`, then have a pair of value $(A, b)$ such that:
$$b = A \times s + e \quad \text{(mod q)} \qquad (1)$$

Let:

$$A = \begin{bmatrix}
a_{11} & a_{12} &\cdots & a_{1n}  \\\\
a_{21} & a_{22} &\cdots & a_{2n}  \\\\
\vdots & \vdots &\ddots & \vdots  \\\\
a_{n1} & a_{n2} &\cdots & a_{nn}  \\\\
\end{bmatrix}, \quad b = 
\begin{bmatrix}
b_{1} \\\\ b_{2} \\\\ \vdots \\\\ b_{n}
\end{bmatrix}, \quad e = 
\begin{bmatrix}
e_{1} \\\\ e_{2} \\\\ \vdots \\\\ e_{n}
\end{bmatrix}, \quad s = 
\begin{bmatrix}
s_{1} \\\\ s_{2} \\\\ \vdots \\\\ s_{n}
\end{bmatrix}
$$

Then we build the basis:

$$B =
\begin{bmatrix}
1       & 0        & \cdots & 0 & a_{11} & a_{21} & \cdots & a_{n1} \\\\
0       & 1        & \cdots & 0 & a_{12} & a_{22} & \cdots & a_{n2} \\\\
\vdots  & \vdots   & \ddots & 1 & a_{1n} & a_{2n} & \cdots & a_{nn} \\\\
0       & 0        & \cdots & 0 & k_{1}  & 0      & \cdots & 0      \\\\
0       & 0        & \cdots & 0 & 0      & k_{2}  & \cdots & 0      \\\\
\vdots  & \vdots   & \ddots & 0 & 0      & 0      & \ddots & k_{n}  \\\\
0       & 0        & \cdots & 0 & -b_{1}  & -b_{2} & \cdots & -b_{n}
\end{bmatrix}$$

We see that there is a small vector

$$v = (s_{1}, s_{2}, \cdots, s_{n}, e_{1}, e_{2}, \cdots, e_{n})$$

generated by this basis. So we just applying **LLL algorithm** to reduce basis $B$, then find the secret vector $s$. With $s$ we easily decrypt the flag by checking

$$b - A \times s \qquad \text{(mod q})$$

is a small vector or not!

## Final script

**`sol.py:`**

```python
from sage.all import *
from Crypto.Util.number import *
from pwn import *

def read_output():
    fi = open('output_patched.txt', 'r').readlines()
    outputs = []
    for line in fi:
      	if len(line) <= 1: continue # avoid empty line
        A, b = line[1:-2].split('] [') # remove brackets
        A = [int(num[1:-1], 16) for num in A.split(', ')]
        b = [int(num[1:-1], 16) for num in b.split(', ')]
        outputs.append((matrix(n, n, A), vector(b)))
    
    return outputs

q = 2**142 + 217
n = 69
nseeds = 142

warn("=== Reading output.txt ===")
outputs = read_output()
info("Done!")

warn("=== Finding secret vector s ===")

info("Building basis...")
A, b = outputs[0]
I = identity_matrix(n)
O = 0*I
Q = q*I 
mt = (I.augment(A.T)).stack(O.augment(Q)).stack(vector([0]*n + [-x for x in b]))
info("Done!")

info("Running LLL...")
s = mt.LLL()[1][:69]
info("Done!")
warn("secret vector s = " + str(s))

flag = ""
for A, b in outputs:
    e = b - A.change_ring(Zmod(q))*s 
    if sum(e) < 7*n:
        flag += "0"
    else:
        flag += "1"

warn("Flag: " + long_to_bytes(int(flag, 2)).decode())
```
**`patch.py:`**

```python
file = open('output.txt', 'r').read()
raw = file.replace('\x00','').split('\n')
output = open('output_patched.txt', 'w', encoding='ascii')
for i in raw:
    if len(i) > 0:
        output.write(i + '\n')
```

## Steps: 

Since the `output.txt` is the raw output, some extra bytes should be removed from it, i.e., `\xff\xfe` and `\x00`.

1. Remove `\xff\xfe` manually at the begin of `output.txt`.
2. Use the following command

```bash
python patch.py
sage -python sol.py
```
